<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    /*
    Promise
    所谓的promise。简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果
    从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法处理
    Promise对象有两个特点
    1）对象的状态不受外界影响。Promise代表一个异步操作，有三种状态：pending-进行中，fulfilled-已成功，rejected-已失败。
    只有一步操作的结果可以当前是哪一种状态，任何其他操作都无法改变这样的状态。
    2）一旦状态改变，就不会在变化，任何时候都可以得到这个结果。
    Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。

     */
//    Promise也有一些缺点。
//    首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。
//    其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
//    第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

//    基本用法
//    ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。
//    const promise = new Promise(function (resolve,reject) {
//
//        if(true){
//            resolve(value);
//        }else{
//            reject(error)
//        }
//    })
//    Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
/*
resolve函数的作用，是将Promise对象的状态从pending变成resolved，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
reject函数的作用，将promise对象的状态从pending变成rejected，在异步操作失败时候调用，作为参数传递出去
 */
//
//promise.then(function (value) {
//    //success
//},function (error) {
//    //error
//})
//    then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。
//    其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。

//    function timeout(ms) {
//        return new Promise((resolve,reject)=>{
//            setTimeout(resolve,ms,'done');
//        })
//    }
//    timeout(1000).then((value) => {
//        console.log(value);
//    });



//    let promise = new Promise(function (resolve,reject) {
//        console.log("Promise");
//        resolve();
//    })
//    promise.then(function () {
//        console.log("resolve")
//    })
//    console.log("Hello")
/*
上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。
 */

/*
一个异步操作的结果是返回另一个异步操作
 */
const p1 = new Promise(function (resolve, reject) {
    setTimeout(()=>reject(new Error('fail')),3000)
})
const p2 = new Promise(function (resolve,reject) {
    setTimeout(()=>resolve(p1),1000)
})
    p2
        .then(result=>console.log(result))
        .catch(error=>console.log(error))
</script>
</html>